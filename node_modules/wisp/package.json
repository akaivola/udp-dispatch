{
  "name": "wisp",
  "id": "wisp",
  "version": "0.10.0",
  "description": "Homoiconic JS with clojure syntax, s-expressions & macros",
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "homepage": "https://github.com/Gozala/wisp",
  "keywords": [
    "compiler",
    "language",
    "transpiler",
    "javascript",
    "lisp",
    "clojure",
    "maros",
    "s-expression",
    "homoiconicity",
    "functional"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/Gozala/wisp.git",
    "web": "https://github.com/Gozala/wisp"
  },
  "bugs": {
    "url": "https://github.com/Gozala/wisp/issues/"
  },
  "licenses": [
    {
      "type": "BSD New",
      "url": "http://opensource.org/licenses/BSD-3-Clause"
    }
  ],
  "devDependencies": {
    "browserify": "2.35.2",
    "wisp": "0.9.0-beta2"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "main": "./wisp.js",
  "bin": {
    "wisp": "./bin/wisp.js"
  },
  "scripts": {
    "prepublish": "make all",
    "test": "make all && make test"
  },
  "dependencies": {
    "escodegen": "git://github.com/Constellation/escodegen.git#master",
    "base64-encode": "~1.0.1",
    "commander": ">=2.2.0"
  },
  "readme": "# WISP\n\n[![Build Status](https://secure.travis-ci.org/Gozala/wisp.png)](http://travis-ci.org/Gozala/wisp)\n\n_wisp_ is a [homoiconic][homoiconicity] JavaScript dialect with [Clojure][]\nsyntax, [s-expressions][] and [macros][]. Unlike [ClojureScript][], _wisp_\ndoes not depend on the JVM and is completely self-hosted, embracing\nnative JavaScript data structures for better interoperability.\n\nThe main goal of _wisp_ is to provide a rich subset of Clojure(Script) so\nthat packages written in _wisp_ can work seamlessly with Clojure(Script) and\nJavaScript without data marshalling or code changes.\n\n_wisp_ also does its best to compile down to JavaScript you would have written\nby hand - think of _wisp_ as [markdown] for JavaScript programming, but with\nthe added subtlety of LISP S-expressions, [homoiconicity][homoiconicity] and\npowerful [macros] that make it the easiest way to write JavaScript.\n\n![meta](http://upload.wikimedia.org/wikipedia/en/b/ba/DrawingHands.jpg)\n\n# Try _Wisp_\n\nYou can try _wisp_ on your browser by [trying the interactive compiler](http://jeditoolkit.com/try-wisp/)\n([repo](https://github.com/Gozala/try-wisp)) or [an online REPL](http://jeditoolkit.com/interactivate-wisp)\nwith syntax highlighting.\n\n# Install\n\nYou can install _wisp_ locally via `npm` by doing:\n\n    npm install -g wisp\n\n...and then running `wisp` to get a REPL. To compile standalone `.wisp` files, simply do:\n\n    cat in.wisp | wisp > out.js\n\n\n# Language Essentials\n\n## Data structures\n\n\n#### nil\n\n`nil` is just like JavaScript `undefined` with the difference that it\ncannot be redefined. It compiles down to `void(0)` in JavaScript.\n\n```clojure\nnil ; => void(0)\n```\n\n#### Booleans\n\n`true` / `false` are directly equivalent to plain JavaScript booleans:\n\n```clojure\ntrue ; => true\n```\n\n#### Numbers\n\n_wisp_ numbers are directly equivalent to JavaScript numbers:\n\n```clojure\n1 ; => 1\n```\n\n#### Strings\n\n_wisp_ strings are JavaScript strings:\n\n```clojure\n\"Hello world\"\n```\n...and can be multi-line:\n\n```clojure\n\"Hello,\nMy name is wisp!\"\n```\n\n#### Characters\n\nCharacters are syntactic sugar for single character strings:\n\n```clojure\n\\a  ; => \"a\"\n\\b  ; => \"b\"\n```\n\n#### Keywords\nKeywords are symbolic identifiers that evaluate to themselves:\n\n```clojure\n:keyword  ; => \"keyword\"\n```\n\nSince in JavaScript string constants fulfill the purpose of symbolic identifiers,\nkeywords compile to equivalent strings in JavaScript. This allows using\nkeywords in Clojure(Script) and JavaScript idiomatic fashion:\n\n```clojure\n(window.addEventListener :load handler false)\n```\n\nKeywords can also be invoked as functions, although that too is syntax sugar\nthat compiles to property access in JavaScript:\n\n```clojure\n(:bar foo) ; => (foo || 0)[\"bar\"]\n```\n\nNote that keywords in _wisp_ are not real functions so they can't be composed\nor passed to high order functions.\n\n#### Vectors\n\n_wisp_ vectors are plain JavaScript arrays, but nevertheless all standard\nlibrary functions are non-destructive and pure functional as in Clojure.\n\n```clojure\n[ 1 2 3 4 ]\n```\nNote: Commas are considered whitespace and can be used if desired:\n\n```clojure\n[1, 2, 3, 4]\n```\n#### Dictionaries\n\n_wisp_ does not have Clojure-like value-to-value maps by default, but rather dictionaries that map to plain JavaScript objects.\n\nTherefore, unlike Clojure, keys cannot consist of arbitrary types.\n\n```clojure\n{ \"foo\" bar :beep-bop \"bop\" 1 2 }\n```\nLike with vectors, commas are optional but can come handy for separating key value pairs.\n\n```clojure\n{ :a 1, :b 2 }\n```\n\n#### Lists\n\nWhat would be a LISP without lists? _wisp_ being homoiconic, its\ncode is made up of lists representing expressions.\n\nAs in other LISPs, the first item of an expression is an operator or function that takes the remainder of the list as arguments, and compiles accordingly to JavaScript:\n\n\n```clojure\n(foo bar baz) ; => foo(bar, baz);\n```\n\nThe compiled JavaScript is quite unlikely to end up with lists as they primarily serve their purpose at compile time. Nevertheless lists are supported and can be used (more further down)\n\n#### Arrays\n\n_wisp_ partially emulates Clojure(Script) handling of arrays in two ways:\n\n1. By using `get`, which compiles to guarded access in JavaScript:\n\n```clojure\n(get [1 2 3] 1) ; => ([1, 2, 3] || 0)[0]\n```\n\n2. By using `aget`, which compiles to unguarded access and can (for the moment) also be used to perform item assignments:\n\n```clojure\n(aget an-array 2) ; => anArray[2];\n(set! (aget an-array 2) \"bar\") ; => anArray[2] = \"bar\";\n```\n\n(`aset` will be added ASAP for symmetry, but you can easily define an equivalent macro for the moment)\n\n## Conventions\n\n_wisp_ tries very hard to compile to JavaScript that feels hand-crafted while trying to embrace LISP-style idioms and naming conventions, and translates them to equivalent JavaScript conventions:\n\n```clojure\n(dash-delimited)   ; => dashDelimited\n(predicate?)       ; => isPredicate\n(**privates**)     ; => __privates__\n(list->vector)     ; => listToVector\n```\n\nThis makes for very natural-looking code, but also allows some things to be expressed in different ways. For instance, the following function invocations will translate to the same things:\n\n```clojure\n(parse-int x)\n(parseInt x)\n\n(array? x)\n(isArray x)\n```\n\n\n## Special forms\n\nThere are some special operators in _wisp_ in the sense that\nthey compile to JavaScript expressions rather then function calls.\n\nIdentically-named functions are also available in the standard library to allow function composition.\n\n#### Arithmetic operations\n\n_wisp_ comes with special forms for common arithmetic:\n\n```clojure\n(+ a b)        ; => a + b\n(+ a b c)      ; => a + b + c\n(- a b)        ; => a - b\n(* a b c)      ; => a * b * c\n(/ a b)        ; => a / b\n(mod a b)      ; => a % 2\n```\n\n#### Comparison operations\n\n...and special forms for common comparisons:\n\n```clojure\n(identical? a b)     ; => a === b\n(identical? a b c)   ; => a === b && b === c\n(= a b)              ; => a == b\n(= a b c)            ; => a == b && b == c\n(> a b)              ; => a > b\n(>= a b)             ; => a >= b\n(< a b c)            ; => a < b && b < c\n(<= a b c)           ; => a <= b && b <= c\n```\n\n#### Logical operations\n\n...and special forms for logical operations:\n\n```clojure\n(and a b)            ; => a && b\n(and a b c)          ; => a && b && c\n(or a b)             ; => a || b\n(and (or a b)\n     (and c d))      ; (a || b) && (c && d)\n```\n\n\n#### Definitions\n\nVariable definitions also happen through special forms:\n\n```clojure\n(def a)     ; => var a = void(0);\n(def b 2)   ; => var b = 2;\n```\n\n#### Assignments\n\nIn _wisp_ variables can be set to new values via the `set!` special form.\n\nNote that in functional programing binding changes are a bad practice (avoiding these will improve the quality and testability of your code), but there are always cases where this is required for JavaScript interoperability:\n\n```clojure\n(set! a 1) ; => a = 1\n```\nThe `!` suffix is a useful visual reminder that you're causing a side-effect.\n\n#### Conditionals\n\nConditional code branching in _wisp_ is expressed via the `Ã¬f` special form.\n\nAs usual, the first expression following `if` is a condition - if it evaluates to `true` the result of the `if` form will be the second expression, otherwise it'll be the third \"else\" expression:\n\n```clojure\n(if (< number 10)\n  \"Digit\"\n  \"Number\")\n```\n\nThe third (\"else\") expression is optional, and if missing and the conditional evaluates to `true` the result will be `nil`.\n\n```clojure\n(if (monday? today) \"How was your weekend\")\n```\n\n#### Combining expressions\n\nIn _wisp_ everything is an expression, but sometimes one might want to combine multiple expressions into one, usually for the purpose of evaluating expressions that have side-effects. That's where `do` comes in:\n\n```clojure\n(do\n  (console.log \"Computing sum of a & b\")\n  (+ a b))\n```\n\n`do` can take any number of expressions (including `0`, in which case it will evaluate to `nil`):\n\n```clojure\n(do) ; => nil\n```\n\n#### Bindings\n\nThe `let` special form evaluates sub-expressions in a lexical context in which symbols in its binding-forms (first item) are bound to their respective expression results:\n\n```clojure\n(let [a 1\n      b (+ a 1)]\n  (+ a b))\n; => 3\n```\n\n\n#### Functions\n\n_wisp_ functions are plain JavaScript functions\n\n```clojure\n(fn [x] (+ x 1)) ; => function(x) { return x + 1; }\n```\n\n_wisp_ functions can have names, just as in JavaScript\n\n```clojure\n(fn increment [x] (+ x 1)) ; => function increment(x) { return x + 1; }\n```\n\n_wisp_ function _declarations_ can also contain documentation and some metadata:\n\n```clojure\n(defn sum\n  \"Return the sum of all arguments\"\n  {:version \"1.0\"}\n  [x] (+ x 1))\n```\n\nFunction _expressions, though, can only have names:\n\n```clojure\n(fn increment\n  {:added \"1.0\"}\n  [x] (+ x 1))\n```\n\n_Note: Docstrings and metadata are not included in compiled JavaScript yet, but support for that is planned._\n\n#### Arguments\n\n_wisp_ makes capturing of remaining (`rest`) arguments a lot easier than JavaScript. An argument that follows an ampersand (`&`) symbol will capture the remaining args in a standard vector (i.e., array).\n\n```clojure\n(fn [x & rest]\n  (rest.reduce (fn [sum x] (+ sum x)) x))\n```\n\n#### Overloading Functions\n\nIn _wisp_ functions can be overloaded depending on arity (the number of arguments they take), without introspection of remaining arguments.\n\n```clojure\n(fn sum\n  \"Return the sum of all arguments\"\n  {:version \"1.0\"}\n  ([] 0)\n  ([x] x)\n  ([x y] (+ x y))\n  ([x & more] (more.reduce (fn [x y] (+ x y)) x)))\n```\n\nIf a function does not have variadic overload and more arguments are passed to it, it throws an exception.\n\n```clojure\n(fn\n  ([x] x)\n  ([x y] (- x y)))\n```\n\n#### Loops and TCO\n\nA classic way to build a loop in LISP is via recursion,  _wisp_ provides a `loop` `recur` construct that allows for tail call optimization:\n\n```clojure\n(loop [x 10]\n  (if (> x 1)\n    (print x)\n    (recur (- x 2))))\n```\n\n## Other Special Forms\n\n### Instantiation\n\nIn _wisp_ type instantiation has a concise form, by way of suffixing the function with a period (`.`):\n\n```clojure\n(Type. options)\n```\n\nHowever, the more verbose but more JavaScript-like form is also valid:\n\n```clojure\n(new Class options)\n```\n\n#### Method calls\n\nIn _wisp_ method calls are no different from function calls, but prefixed with a period (`.`):\n\n```clojure\n(.log console \"hello wisp\")\n```\n\n...and, of course, the more JavaScript-like forms are supported too:\n\n```clojure\n(window.addEventListener \"load\" handler false)\n```\n\n#### Attribute access\n\nIn _wisp_, attribute access is also treated like a function call, but attributes need to be prefixed with `.-`:\n\n```clojure\n(.-location window)\n```\n\nCompound properties can be accessed via the `get` special form:\n\n```clojure\n(get templates (.-id element))\n```\n\n#### Catching Exceptions\n\nIn _wisp_ exceptions can be handled via the `try` special form. As with everything\nelse, the `try` form is also an expression that evaluates to `nil` if no handling\ntakes place.\n\n```clojure\n(try (raise exception))\n```\n\n...the `catch` form can be used to handle exceptions...\n\n```clojure\n(try\n  (raise exception)\n  (catch error (.log console error)))\n```\n\n...and the `finally` clause can be used too:\n\n```clojure\n(try\n  (raise exception)\n  (catch error (recover error))\n  (finally (.log console \"That was a close one!\")))\n```\n\n\n#### Throwing Exceptions\n\nIn a non-idiomatic twist (but largely for symmetry and JavaScript interop), the `throw` special form allows throwing exceptions:\n\n```clojure\n(fn raise [message] (throw (Error. message)))\n```\n\n## Macros\n\n_wisp_ has a powerful programmatic macro system which allows the compiler to\nbe extended by user code.\n\nMany core constructs of _wisp_ are in fact normal macros, and you are encouraged to study the source to learn how to build your own. Nevertheless, the following sections are a quick primer on macros.\n\n#### quote\n\nBefore diving into macros too much, we need to learn a few more\nthings. In LISP any expression can be quoted to prevent it from being\nevaluated.\n\nAs an example, take the symbol `foo` - by default, you will be\nevaluating the reference to its corresponding value:\n\n```clojure\nfoo\n```\n\nBut if you wish to refer to the literal symbol, this is how you do it:\n\n```clojure\n(quote foo)\n```\n\nor, as shorthand:\n\n```clojure\n'foo\n```\n\nAny expression can be quoted to prevent its evaluation (these are not, however, compiled to JavaScript):\n\n```clojure\n'foo\n':bar\n'(a b)\n```\n\n#### An Example Macro\n\n_wisp_ doesn't have the `unless` special form or a macro, but it's trivial\nto implement it via macros.\n\nBut it's useful to try implementing it as a function to understand a use case for macros, so let's get started:\n\n`unless` is easy to understand -- we want to execute a `body` unless a given `condition` is `true`:\n\n```clojure\n(defn unless-fn [condition body]\n  (if condition nil body))\n```\n\nBut since function arguments are evaluated before the function itself is called, the following code will _always_ write a log message:\n\n```clojure\n(unless-fn true (console.log \"should not print\"))\n```\n\nMacros solve this problem, because they do not evaluate their arguments\nimmediately. Instead, you get to choose when (and if!) the arguments\nto a macro are evaluated. Macros take items of the expression as\narguments and return a new form that is compiled instead.\n\n```clojure\n(defmacro unless\n  [condition form]\n  (list 'if condition nil form))\n```\n\nThe body of the `unless` macro executes at macro expansion time, producing an `if`\nform for compilation. This way the compiled JavaScript is a conditional instead of a function call.\n\n```clojure\n(unless true (console.log \"should not print\"))\n```\n\n#### syntax-quote\n\nSimple macros like the above could be written via templating and expressed\nas syntax-quoted forms.\n\n`syntax-quote` is almost the same as plain `quote`, but it allows\nsub expressions to be unquoted so that form acts as a template.\n\nThe symbols inside the form are resolved to help prevent inadvertent symbol capture, which can be done via `unquote` and `unquote-splicing` forms.\n\n```clojure\n(syntax-quote (foo (unquote bar)))\n(syntax-quote (foo (unquote bar) (unquote-splicing bazs)))\n```\n\nNote that there is special syntactic sugar for both unquoting operators:\n\n1. Syntax quote: Quote the form, but allow internal unquoting so that the form acts\nas template. Symbols inside the form are resolved to help prevent inadvertent symbol\ncapture.\n\n```clojure\n`(foo bar)\n```\n\n2. Unquote: Use inside a syntax-quote to substitute an unquoted value.\n\n```clojure\n`(foo ~bar)\n```\n\n3. Splicing unquote: Use inside a syntax-quote to splice an unquoted\nlist into a template.\n\n```clojure\n`(foo ~bar ~@bazs)\n```\n\nFor example, the built-in `defn` macro can be defined with a simple\ntemplate macro. That's more or less how the built-in `defn` macro is implemented.\n\n```clojure\n(defmacro define-fn\n  [name & body]\n  `(def ~name (fn ~@body)))\n```\n\nNow if we use `define-fn` form above, the defined macro will be expanded\nat compile time, resulting into different program output.\n\n```clojure\n(define-fn print\n  [message]\n  (.log console message))\n```\n\nNot all of the macros can be expressed via templating, but all of the\nlanguage is available to assemble macro expanded forms.\n\n#### Another Macro Example\n\nAs an example, let's define a macro to ease functional chaining, a technique popular\nin JavaScript but usually expressed via method chaining. A typical use of that would be something like:\n\n```javascript\nopen(target, \"keypress\").\n  filter(isEnterKey).\n  map(getInputText).\n  reduce(render)\n```\n\nUnfortunately, though, it usually requires that all the chained functions need to be methods of an object, which is very limited and has the undesirable effect of making third party functions \"second class\".\n\nBut using macros we can achieve similar chaining without such tradeoffs, and chain _any_ function:\n\n```clojure\n(defmacro ->\n  [& operations]\n  (reduce\n   (fn [form operation]\n     (cons (first operation)\n           (cons form (rest operation))))\n   (first operations)\n   (rest operations)))\n\n(->\n (open target :keypress)\n (filter enter-key?)\n (map get-input-text)\n (reduce render))\n```\n\n## Import/Export (Symbols and Modules)\n\n### Exporting Symbols\n\nAll the top level definitions in a file are exported by default:\n\n```clojure\n(def foo bar)\n(defn greet [name] (str \"hello \" name))\n```\n\n...but it's still possible to define top level bindings without exporting them via `^:private` metadata:\n\n```clojure\n(def ^:private foo bar)\n```\n\n...and a little syntax sugar for functions:\n\n```clojure\n(defn- greet [name] (str \"hello \" name))\n```\n\n\n### Importing\n\nModule importing is done via an `ns` special form that is manually\nnamed. Unlike `ns` in Clojure(Script), _wisp_ takes a minimalistic\napproach and supports only one essential way of importing modules:\n\n```clojure\n(ns interactivate.core.main\n  \"interactive code editing\"\n  (:require [interactivate.host :refer [start-host!]]\n            [fs]\n            [wisp.backend.javascript.writer :as writer]\n            [wisp.sequence\n             :refer [first rest]\n             :rename {first car rest cadr}]))\n```\n\nLet's go through the above example to get a complete picture regarding\nhow modules can be imported:\n\n1. The first parameter `interactivate.core.main` is a name of the\nmodule / namespace. In this case it represents module\n`./core/main` under the package `interactivate`. While this is\nnot enforced in any way the common convention is that these mirror the filesystem hierarchy.\n\n2. The second string parameter is just a description of the module\nand is completely optional.\n\n3. The `(:require ...)` form defines dependencies that will be\nimported at runtime, and the example above imports multiple modules:\n\n  1. First it imports the `start-host!` function from the\n     `interactivate.host` module. That will be loaded from the\n     `../host` location, since because module paths are resolved\n     relative to a name, but only if they share the same root.\n  2. The second form imports `fs` module and makes it available under\n     the same name. Note that in this case it could have been\n     written without wrapping it in brackets.\n  3. The third form imports `wisp.backend.javascript.writer` module\n     from `wisp/backend/javascript/writer` and makes it available\n     via the name `writer`.\n  4. The last and most complex form imports `first` and `rest`\n     functions from the `wisp.sequence` module, although it also\n     renames them and there for makes available under different\n     `car` and `cdr` names.\n\nWhile Clojure has many other kinds of reference forms they are\nnot recognized by _wisp_ and will therefore be ignored.\n\n### Types and Protocols\n\nIn wisp protocols can be defined same as in Clojure(Script),\nvia [defprotocol](http://clojuredocs.org/clojure_core/clojure.core/defprotocol):\n\n```clojure\n(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))\n\n(defprotocol ICounted\n  (^number count [coll] \"constant time count\"))\n```\n\nAbove code will define `ISeq`, `ICounted` protocols (objects representing\nthose protocol) and `_first`, `_rest`, `count` functions, that dispatch on\nfirst argument (that must implement associated protocol).\n\n\nExisting types / classes (defined either in wisp or JS) can be\nextended to implement specific protocol using\n[extend-type](http://clojuredocs.org/clojure_core/clojure.core/extend-type):\n\n```clojure\n(extend-type Array\n  ICounted\n  (count [array] (.-length array))\n  ISeq\n  (-first [array] (aget array 0))\n  (-rest [array] (.slice array 1)))\n```\n\nOnce type / class implemnets some protocol, it's functions can be used\non the instances of that type / class.\n\n```clojure\n(count [])        ;; => 0\n(count [1 2])     ;; => 2\n(-first [1 2 3])  ;; => 1\n(-rest [1 2 3])   ;; => [2 3]\n```\n\nIn wisp value can be checked to satisfy given protocol same as in\nClojure(Script) via [satisfies?](http://clojuredocs.org/clojure_core/clojure.core/satisfies_q):\n\n```clojure\n(satisfies? ICounted [1 2])\n(satisfies? ISeq [])\n```\n\nNew types (that translate to JS classes) can be defined same as in\nClojure(Script) via [deftype](http://clojuredocs.org/clojure_core/clojure.core/deftype)\nform:\n\n```clojure\n(deftype List [head tail size]\n  ICounted\n  (count [_] size)\n  ISeq\n  (-first [_] head)\n  (-rest [_] tail)\n  Object\n  (toString [self] (str \"(\" (join \" \" self) \")\")))\n```\n\nNote: Protocol functions are defined as methods with unique names\n(that include namespace info where protocol was defined, protocol\nname & method name) to avoid name collisions on types / classes\nimplementing them. This implies that such methods aren't very\nuseful from JS side. Special `Object` protocol can be used to\ndefine methods who's names will be kept as is, which can be used\nto define interface to be used from JS side (like `toString`\nmethod above).\n\nIn wisp multiple types can be extended to implement a specific\nprotocol using [extend-protocol](http://clojuredocs.org/clojure_core/clojure.core/extend-protocol)\nform same as in Clojure(Script) too.\n\n[homoiconicity]:http://en.wikipedia.org/wiki/Homoiconicity\n[clojure]:http://clojure.org/\n[macros]:http://clojure.org/macros\n[s-expressions]:http://en.wikipedia.org/wiki/S-expression\n[clojurescript]:https://github.com/clojure/clojurescript\n[markdown]:http://daringfireball.net/projects/markdown/\n\n",
  "readmeFilename": "Readme.md",
  "_id": "wisp@0.10.0",
  "_from": "wisp@*"
}
