(ns wisp.core.arithmetic
  (:require [wisp.core.counted :refer [count]]
            [wisp.core.indexed :refer [nth]]))

(defn ^number inc
  [^number x]
  (+ x 1))

(defn ^number dec
  [^number x]
  (- x 1))


(defn ^boolean >
  "Returns non-nil if nums are in monotonically decreasing order,
  otherwise false."
  ([x] true)
  ([x y] (> x y))
  ([x y & more]
   (loop [previous x
          current y
          index 0
          n (count more)]
    (and (> previous current)
         (if (< index n)
          (recur current
                 (nth more index)
                 (inc index)
                 n)
          true)))))

(defn ^boolean >=
  "Returns non-nil if nums are in monotonically decreasing order,
  otherwise false."
  ([x] true)
  ([x y] (>= x y))
  ([x y & more]
   (loop [previous x
          current y
          index 0
          n (count more)]
    (and (>= previous current)
         (if (< index n)
          (recur current
                 (nth more index)
                 (inc index)
                 n)
          true)))))


(defn ^boolean <
  "Returns non-nil if nums are in monotonically decreasing order,
  otherwise false."
  ([x] true)
  ([x y] (< x y))
  ([x y & more]
   (loop [previous x
          current y
          index 0
          n (count more)]
    (and (< previous current)
         (if (< index n)
          (recur current
                 (nth more index)
                 (inc index)
                 n)
          true)))))


(defn ^boolean <=
  "Returns non-nil if nums are in monotonically decreasing order,
  otherwise false."
  ([x] true)
  ([x y] (<= x y))
  ([x y & more]
   (loop [previous x
          current y
          index 0
          n (count more)]
    (and (<= previous current)
         (if (< index n)
          (recur current
                 (nth more index)
                 (inc index)
                 n)
          true)))))

(defn ^boolean +
  ([] 0)
  ([a] a)
  ([a b] (+ a b))
  ([a b c] (+ a b c))
  ([a b c d] (+ a b c d))
  ([a b c d e] (+ a b c d e))
  ([a b c d e f] (+ a b c d e f))
  ([a b c d e f & more]
   (loop [value (+ a b c d e f)
          index 0
          n (count more)]
     (if (< index n)
       (recur (+ value (nth more index))
              (inc index)
              n)
       value))))

(defn ^boolean -
  ([] (throw (TypeError "Wrong number of args passed to: -")))
  ([a] (- 0 a))
  ([a b] (- a b))
  ([a b c] (- a b c))
  ([a b c d] (- a b c d))
  ([a b c d e] (- a b c d e))
  ([a b c d e f] (- a b c d e f))
  ([a b c d e f & more]
   (loop [value (- a b c d e f)
          index 0
          n (count more)]
     (if (< index n)
       (recur (- value (nth more index))
              (inc index)
              n)
       value))))

(defn ^boolean /
  ([] (throw (TypeError "Wrong number of args passed to: /")))
  ([a] (/ 1 a))
  ([a b] (/ a b))
  ([a b c] (/ a b c))
  ([a b c d] (/ a b c d))
  ([a b c d e] (/ a b c d e))
  ([a b c d e f] (/ a b c d e f))
  ([a b c d e f & more]
   (loop [value (/ a b c d e f)
          index 0
          n (count more)]
     (if (< index n)
       (recur (/ value (nth more index))
              (inc index)
              n)
       value))))

(defn ^boolean *
  ([] 1)
  ([a] a)
  ([a b] (* a b))
  ([a b c] (* a b c))
  ([a b c d] (* a b c d))
  ([a b c d e] (* a b c d e))
  ([a b c d e f] (* a b c d e f))
  ([a b c d e f & more]
   (loop [value (* a b c d e f)
          index 0
          n (count more)]
     (if (< index n)
       (recur (* value (nth more index))
              (inc index)
              n)
       value))))
