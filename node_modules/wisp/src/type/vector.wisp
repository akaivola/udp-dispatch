(ns wisp.type.vector
  (:require [wisp.interface.meta :refer [IMeta IWithMeta]]
            [wisp.interface.equal :refer [IEqual]]
            [wisp.interface.sequential :refer [ISequential ICastSequential]]
            [wisp.interface.vector :refer [IVector vector?]]
            [wisp.interface.counted :refer [ICounted]]
            [wisp.interface.conjoinable :refer [IConjoinable]]
            [wisp.interface.emptiable :refer [IEmptiable]]
            [wisp.interface.stack :refer [IStack]]

            [wisp.type.sequential :refer [write-sequential equal-sequential?]]))

(defn write-vector
  [writer source options]
  (write-sequential writer source "[" "]" " " options))

(defn vector->string
  [source]
  (write-sequential "" source "[" "]" " " nil))

(extend-type js/Array
  IVector
  IMeta
  (-meta [array] (aget array "wisp.metadata"))

  IWithMeta
  (-with-meta [source metadata]
    (js/Object.defineProperty (.slice source 0)
                              "wisp.metadata"
                              {:value metadata}))

  ISequential
  (-first [source] (aget source 0))
  (-rest [_] (.slice source 0))

  ICastSequential
  (->sequential [source] source)

  IEnumerable
  (-next [source]
    (if (> (.-length source) 1)
      (.slice source 1)))

  IStack
  (-peek [source]
    (aget source (- (.-length source) 1)))
  (-pop [source]
    (if (identical? (.-length source) 0)
      (throw (js/Error. "Can't pop empty array"))
      (.slice source 0 (- (.-length source) 2))))

  IConjoinable
  (-conj [source item]
    (.concat source [items]))

  IEmptiable
  (-empty [source] (-with-meta [] (-meta source)))

  ICounted
  (-count [source] (.-length source))

  IWritable
  (-write [writer source options]
    (write-vector writer source options))

  IEqual
  (-equal [source other]
    (and (vector? other)
         (equal-sequential? source other))))
