(ns wisp.core.list
  (:require [wisp.interface.sequential :refer [ISequential ICastSequential ->sequential
                                               seq? sequential?]]
            [wisp.interface.enumerable :refer [-next]]
            [wisp.interface.writer :refer [-append]]
            [wisp.interface.equal :refer [=]]
            [wisp.interface.nil :refer [nil?]]

            [wisp.core.arithmetic :refer [> dec inc]]))

(def first -first)
(def rest -rest)

(defn equal-sequential?
  "Assumes x is sequential. Returns true if x equals y, otherwise
  returns false."
  [x y]
  (if (sequential? y)
    (loop [xs (->sequential x)
           ys (write-sequential y)]
      (cond (nil? xs)
            (nil? ys)

            (nil? ys)
            false

            (= (first xs) (first ys))
            (recur (-next xs) (-next ys))

            :else false))))

(defn write-sequential
  [writer source begin separator end options]
  (let [prefix (-append writer begin)
        body (loop [output (if (->sequential source)
                             (write prefix (first source) options)
                             prefix)
                    items (-next source)
                    n (dec (:print-length options))]
               (cond (and items
                          (or (nil? n)
                              (> n 0)))
                     (recur (write (-append output separator options)
                                   (first items)
                                   options)
                            (-next items)
                            (dec n))

                     (and (->sequential items)
                          (identical? n 0))
                     (-append (-append output separator options)
                             "..."
                             options)

                     :else
                     output))]
    (-append body end options)))
