(ns wisp.type.map
  (:require [wisp.interface.meta :refer [IMeta IWithMeta]]
            [wisp.interface.equal :refer [IEqual]]
            [wisp.interface.sequential :refer [ISequential ICastSequential]]
            [wisp.interface.map :refer [IMap map?]]
            [wisp.interface.vector :refer [IVector]]
            [wisp.interface.counted :refer [ICounted]]
            [wisp.interface.conjoinable :refer [IConjoinable]]
            [wisp.interface.emptiable :refer [IEmptiable]]
            [wisp.interface.stack :refer [IStack]]
            [wisp.interface.protocol :refer [satisfies?]]

            [wisp.core.sequential :refer [write-sequential equal-sequential?]]))

(defn write-list
  [writer source options]
  (write-sequential writer source "{" "}" " " options))

(defn vector->string
  [source]
  (write-sequential "" source "{" "}" " " nil))

(extend-type js/Object
  IMap
  IMeta
  (-meta [array] (aget array "wisp.metadata"))

  IWithMeta
  (-with-meta [source metadata]
    (js/Object.defineProperty (.slice source 0)
                              "wisp.metadata"
                              {:value metadata}))

  IConjoinable
  (-conj [source entry]
    (if (satisfies? IVector entry)
      (-assoc source (-nth entry 0) (-nth entry 1))
      (loop [result source
             entries (->sequential entry)]
        (if (satisfies? INil entries)
          result
          (let [entry (first entries)]
            (if (satisfies? IVector entry)
              (recur (-assoc result (-nth entry 0) (-nth entry 1))
                     (-next entries))
              (throw (js/Error. "conj on a map takes map entries or seqables of map entries"))))))))


  ISequential
  (-first [source] (aget source 0))
  (-rest [_] (.slice source 0))

  ICastSequential
  (->sequential [source] source)

  IEnumerable
  (-next [source]
    (if (> (.-length source) 1)
      (.slice source 1)))

  IStack
  (-peek [source]
    (aget source (- (.-length source) 1)))
  (-pop [source]
    (if (identical? (.-length source) 0)
      (throw (js/Error. "Can't pop empty array"))
      (.slice source 0 (- (.-length source) 2))))


  IEmptiable
  (-empty [source] (-with-meta [] (-meta source)))

  ICounted
  (-count [source] (.-length source))

  IWritable
  (-write [writer source options]
    (write-vector writer source options))

  IEqual
  (-equal [source other]
    (and (satisfies? IVector other))
    (equal-sequential? source other)))

