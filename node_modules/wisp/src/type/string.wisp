(ns wisp.type.string
  (:require [wisp.interface.string :refer [IString string?
                                           subs split split-lines blank?
                                           join upper-case lower-case capitalize
                                           replace-first replace triml trimr trim]]
            [wisp.interface.boolean :refer [ICastBoolean]]
            [wisp.interface.sequential :refer [ISequential ICastSequential]]
            [wisp.interface.reversible :refer [IReversible]]
            [wisp.interface.counted :refer [ICounted]]
            [wisp.interface.indexed :refer [IIndexed]]
            [wisp.interface.meta :refer [IMeta IWithMeta]]
            [wisp.interface.named :refer [INamed]]
            [wisp.interface.equal :refer [IEqual]]
            [wisp.interface.protocol :refer [satisfies?]]
            [wisp.interface.re-pattern :refer [IRePattern -source]]
            [wisp.interface.writable :refer [IWritable]]
            [wisp.interface.writer :refer [-append]]))

(defn quote-string
  [s]
  (set! s (join "\\\"" (split s "\"")))
  (set! s (join "\\\\" (split s "\\")))
  (set! s (join "\\b" (split s "\b")))
  (set! s (join "\\f" (split s "\f")))
  (set! s (join "\\n" (split s "\n")))
  (set! s (join "\\r" (split s "\r")))
  (set! s (join "\\t" (split s "\t")))
  (str "\"" s "\""))

(def ^:private **escape-pattern**
  (js/RegExp. "([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])" "g"))


(defn- escape-pattern
  [source]
  (.replace (.replace source **escape-pattern** "\\$1")
            (js/RegExp. "\\x08" "g"), "\\x08"))


(deftype StringWithMetadata
  [metadata value]

  Object
  (toString [_] (.toString value))
  (valueOf [_] (.valueOf value))

  IMeta
  (-meta [_] metadata)

  IWithMeta
  (-with-meta [_]
    (StringWithMetadata. metadata value))

  ICounted
  (-count [_] (.-length value))

  IIndexed
  (-nth [_ n not-found]
    (if (< n (.-length value))
      (.substr value n 1)
      not-found))

  ISequential
  (-first [_] (.substr value 0 1))
  (-rest [_] (.substr value 1))

  ICastSequential
  (->sequential [source] source)

  INamed
  (-name [_] value)

  IWritable
  (-write [_] (-append writer (quote-string value)))

  IEqual
  (-equal [_ other]
    (or (identical? value other)
        (and (string? other)
             (identical? value (str other)))))

  ICastBoolean
  (->boolean [_] true)

  IString
  (subs [_ start end]
    (.substring value start end))
  (split [_ pattern limit]
    (.split value pattern limit))
  (split-lines [_]
    (.split value #"\n|\r\n"))
  (join [_ sequential]
    (.join (vec sequential) value))
  (upper-case [_] (.toUpperCase value))
  (lower-case [_] (.toLowerCase value))
  (capitalize [_]
    (if (< (.-length value) 2)
      (.toUpperCase value)
      (.concat (.toUpperCase (.substring value 0 1))
               (.toLowerCase (.substring value 1)))))
  (replace-first [_ match replacement]
    (.replace value match replacement))
  (replace [_ match replacement]
    (cond (string? match)
          (.replace value
                    (js/RegExp. (escape-pattern match) "g")
                    replacement)

          (re-pattern? match)
          (.replace value
                    (js/RegExp. (-source match) "g")
                    replacement)

          :else
          (throw (str "Invalid match argument: " match))))
  (triml [_] (.replace value #"^\s*" ""))
  (trimr [_] (.replace value #"\s*$" ""))
  (trim [_]
    (.replace (.replace value #"^\s*" "")
              #"\s*$" ""))
  (blank? [_]
    (or (identical? (.-length value) 0)
        (identical? (.-length (trim value)) 0)))

  IReversible
  (reverse [_]
    (.join (.reverse (.split value "")) "")))

(extend-type string
  IMeta
  (-meta [_] nil)

  IWithMeta
  (-with-meta [value metadata]
    (.StringWithMetadata metadata value))

  ICounted
  (-count [value] (.-length string))

  IIndexed
  (-nth [value n not-found]
    (if (< n (.-length string))
      (.substr value n 1)
      not-found))

  ISequential
  (-first [value] (-nth value 0 nil))
  (-rest [value] (.substring value 1))

  ICastSequential
  (->sequential [value] value)

  INamed
  (-name [value] value)

  IWritable
  (-write [_] (-append writer (quote-string value)))

  IEqual
  (-equal [value other]
    (or (identical? value other)
        (and (string? other)
             (identical? value (str other)))))



  ICastBoolean
  (->boolean [_] true)

  IString
  (subs [value start end]
    (.substring value start end))
  (split [value pattern limit]
    (.split value pattern limit))
  (split-lines [value]
    (.split value #"\n|\r\n"))
  (join [value sequential]
    (.join (vec sequential) value))
  (upper-case [value] (.toUpperCase value))
  (lower-case [value] (.toLowerCase value))
  (capitalize [value]
    (if (< (.-length value) 2)
      (.toUpperCase value)
      (.concat (.toUpperCase (.substring value 0 1))
               (.toLowerCase (.substring value 1)))))
  (replace-first [value match replacement]
    (.replace value match replacement))
  (replace [value match replacement]
    (cond (string? match)
          (.replace value
                    (js/RegExp. (escape-pattern match) "g")
                    replacement)

          (re-pattern? match)
          (.replace value
                    (js/RegExp. (-source match) "g")
                    replacement)

          :else
          (throw (str "Invalid match argument: " match))))
  (triml [value] (.replace value #"^\s*" ""))
  (trimr [value] (.replace value #"\s*$" ""))
  (trim [value]
    (.replace (.replace value #"^\s*" "")
              #"\s*$" ""))
  (blank? [value]
    (or (identical? (.-length value) 0)
        (identical? (.-length (trim value)) 0)))

  IReversible
  (reverse [value]
    (.join (.reverse (.split value "")) "")))
