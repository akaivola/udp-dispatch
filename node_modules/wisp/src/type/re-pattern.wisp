(ns wisp.type.re-pattern
  (:require [wisp.interface.meta :refer [IMeta IWithMeta]]
            [wisp.interface.re-pattern :refer [IRePattern -source
                                               re-pattern?
                                               re-pattern re-find
                                               re-matches re-seq]]
            [wisp.interface.equal :refer [IEqual]]
            [wisp.interface.writable :refer [IWritable]]
            [wisp.interface.counted :refer [-count]]
            [wisp.interface.indexed :refer [-nth]]
            [wisp.interface.string :refer [join split]]
            [wisp.interface.writer :refer [-append]]]))


(extend-type re-pattern
  IRePattern
  (-source [regexp] (.-source regexp))
  (re-find [source text]
    (let [matches (.exec source text)]
      (if matches
        (if (identical? (-count matches) 1)
          (-nth matches 0)
          matches))))
  (re-matches [source text]
    (let [matches (.exec source text)
          first-match (-nth matches 0)]
      (if (and matches
               (identical? first-match text))
        (if (identical? (-count matches) 1)
          first-match
          matches))))
  (re-seq [pattern text]
    (throw (js/Error "Not implemented")))

  IMeta
  (-meta [regexp] (-lookup regexp "wisp.metadata"))

  IWithMeta
  (-with-meta [source metadata]
    (js/Object.defineProperty (js/RegExp. (.-source regexp))
                              "wisp.metadata"
                              {:value metadata}))

  IWritable
  (-write [source writer options]
    (-append writer
            (str "#\""
                 (join "\\/" (split (.-source x) "/"))
                 "\"")))

  IEqual
  (-equal [source other]
    (or (identical? source other)
        (and (re-pattern? other)
             (identical? (.-source source)
                         (-source other))))))
