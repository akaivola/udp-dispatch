(ns wisp.type.list
  (:require [wisp.interface.meta :refer [IMeta IWithMeta]]
            [wisp.interface.equal :refer [IEqual]]
            [wisp.interface.sequential :refer [ISequential ICastSequential]]
            [wisp.interface.list :refer [IList list?]]
            [wisp.interface.counted :refer [ICounted]]
            [wisp.interface.conjoinable :refer [IConjoinable]]
            [wisp.interface.emptiable :refer [IEmptiable]]
            [wisp.interface.stack :refer [IStack]]
            [wisp.interface.protocol :refer [satisfies?]]

            [wisp.type.nil :refer [nil?]]

            [wisp.core.sequential :refer [write-sequential equal-sequential?]]
            [wisp.core.arithmetic :refer [inc]]))

(defn write-list
  [writer source options]
  (write-sequential writer source "(" ")" " " options))

(defn list->string
  [source]
  (write-sequential "" source "(" ")" " " nil))

(deftype List
  [metadata head tail n ^:mutable hash]
  IList

  Object
  (toString [source] (list->string source))

  IMeta
  (-meta [_] metadata)

  IWithMeta
  (-with-meta [_ new-metadata]
    (List. new-metadata head tail n hash))


  ISequential
  (-first [_] head)
  (-rest [_] tail)

  ICastSequential
  (->sequential [source] source)

  IEnumerable
  (-next [_]
    (if (> n 1) tail))

  IStack
  (-peek [_] head)
  (-pop [_] tail)

  IConjoinable
  (-conj [source item]
    (List. metadata item source (inc n) nil))

  IEmptiable
  (-empty [source] EMPTY)

  ICounted
  (-count [_] n)

  IWritable
  (-write [writer source options]
    (write-list writer source options))

  IEqual
  (-equal [source other]
    (equal-sequential? source other)))

(deftype EmptyList [metadata]
  IList

  Object
  (toString [source] (list->string source))

  IWithMeta
  (-with-meta [_ new-metadata] (EmptyList. new-metadata))

  IMeta
  (-meta [_] metadata)

  ISequential
  (-first [_] nil)
  (-rest [_] EMPTY)

  ICastSequential
  (->sequential [_] nil)

  IEnumerable
  (-next [_] nil)

  IStack
  (-peek [_] nil)
  (-pop [_] (throw (js/Error. "Can't pop empty list")))

  IConjoinable
  (-conj [tail head] (List. metadata head tail 1 nil))

  IEmptiable
  (-empty [source] source)

  IEqual
  (-equal [source other]
    (equal-sequential? source other))

  ICounted
  (-count [_] 0)

  IWritable
  (-write [source writer options]
    (write-list writer source)))

(def EMPTY (EmptyList.))

(deftype Cons [metadata head tail ^:mutable hash]
  IList

  Object
  (toString [source] (list->string source))

  IWithMeta
  (-with-meta [_ new-metadata] (Cons. new-metadata head tail hash))

  IMeta
  (-meta [_] metadata)

  ISequential
  (-first [_] head)
  (-rest [_] (or tail ()))

  ICastSequential
  (->sequential [source] source)

  IEnumerable
  (-next [_]
    (if (nil? tail) nil (->sequential tail)))

  IConjoinable
  (-conj [tail head]
    (Cons. metadata head tail hash))

  IEmptiable
  (-empty [_] (with-meta EMPTY metadata))

  ICounted
  (-count [_] (inc (-count tail)))

  IEqual
  (-equal [source other]
    (equal-sequential? source other)))
