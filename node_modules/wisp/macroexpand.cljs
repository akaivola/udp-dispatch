(ns wisp.macroexpand
  (:require [wisp.runtime :refer [string? dictionary? =]]
            [wisp.expander :refer [install-macro!]]
            [wisp.ast :refer [meta with-meta name]]
            [wisp.analyzer :refer [empty-env analyze analyze*]]
            [wisp.backend.escodegen.writer :refer [write compile write*]]
            [wisp.sequence :refer [vec nth first second drop list]]))

(defn with-doc
  [doc & body]
  (if (string? doc)
    `[~doc ~@body]
    `[" "  ~doc ~@body]))


(defn with-metadata
  [doc metadata & body]
  (if (dictionary? metadata)
    `[~doc ~metadata ~@body]
    `[~doc {} ~metadata ~@body]))


(defn parse-defmacro
  [forms]
  (let [body (apply with-metadata (apply with-doc forms))
        params (nth body 2)
        include-form (= (first params) '&form)
        include-env (= (second params) '&env)]
    {:doc (first body)
     :metadata (second body)
     :params params
     :body (drop 3 body)
     :include-form include-form
     :inclued-env include-env}))

(def define-macro
  (fn [&form &env id & body]
    (let [node (parse-defmacro body)
          doc (:doc node)
          params (:params node)
          metadata (:metadata node)
          body (:body node)
          ns-id (name (:name (:ns &env)))
          macro-id (str ns-id "$" (name id))

          macro `(do
                   (defn ~id
                     ~doc
                     ~metadata
                     ~params
                     ~@body)
                   (set! (aget this ~macro-id) ~id)
                   ~id)

          ast (analyze macro)
          code (compile ast)]
      (do
        (install-macro! id (eval code))
        macro))))


(install-macro! 'define-macro (with-meta define-macro {:implicit [:&form :&env]}))
