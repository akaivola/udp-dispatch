{
    var _ns_ = {
            id: 'wisp.ast',
            doc: void 0
        };
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var isSequential = wisp_sequence.isSequential;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var count = wisp_sequence.count;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var repeat = wisp_sequence.repeat;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isVector = wisp_runtime.isVector;
    var isNumber = wisp_runtime.isNumber;
    var isString = wisp_runtime.isString;
    var isBoolean = wisp_runtime.isBoolean;
    var isObject = wisp_runtime.isObject;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isDictionary = wisp_runtime.isDictionary;
    var str = wisp_runtime.str;
    var inc = wisp_runtime.inc;
    var subs = wisp_runtime.subs;
    var isEqual = wisp_runtime.isEqual;
}
var withMeta = exports.withMeta = function withMeta(value, metadata) {
        Object.defineProperty(value, 'metadata', {
            'value': metadata,
            'configurable': true
        });
        return value;
    };
var meta = exports.meta = function meta(value) {
        return isNil(value) ? void 0 : value.metadata;
    };
var __nsSeparator__ = exports.__nsSeparator__ = '\u2044';
var Symbol = function Symbol(namespace, name) {
    this.namespace = namespace;
    this.name = name;
    return this;
};
Symbol.type = 'wisp.symbol';
Symbol.prototype.type = Symbol.type;
Symbol.prototype.toString = function () {
    return function () {
        var prefixø1 = '' + '\uFEFF' + '\'';
        var nsø1 = namespace(this);
        return nsø1 ? '' + prefixø1 + nsø1 + '/' + name(this) : '' + prefixø1 + name(this);
    }.call(this);
};
var symbol = exports.symbol = function symbol(ns, id) {
        return isSymbol(ns) ? ns : isKeyword(ns) ? new Symbol(namespace(ns), name(ns)) : isNil(id) ? new Symbol(void 0, ns) : 'else' ? new Symbol(ns, id) : void 0;
    };
var isSymbol = exports.isSymbol = function isSymbol(x) {
        return isString(x) && '\uFEFF' === x[0] && '\'' === x[1] || x && Symbol.type === x.type;
    };
var isKeyword = exports.isKeyword = function isKeyword(x) {
        return isString(x) && count(x) > 1 && first(x) === '\uA789';
    };
var keyword = exports.keyword = function keyword(ns, id) {
        return isKeyword(ns) ? ns : isSymbol(ns) ? '' + '\uA789' + name(ns) : isNil(id) ? '' + '\uA789' + ns : isNil(ns) ? '' + '\uA789' + id : 'else' ? '' + '\uA789' + ns + __nsSeparator__ + id : void 0;
    };
var keywordName = function keywordName(value) {
    return last(split(subs(value, 1), __nsSeparator__));
};
var symbolName = function symbolName(value) {
    return value.name || last(split(subs(value, 2), __nsSeparator__));
};
var name = exports.name = function name(value) {
        return isSymbol(value) ? symbolName(value) : isKeyword(value) ? keywordName(value) : isString(value) ? value : 'else' ? (function () {
            throw new TypeError('' + 'Doesn\'t support name: ' + value);
        })() : void 0;
    };
var keywordNamespace = function keywordNamespace(x) {
    return function () {
        var partsø1 = split(subs(x, 1), __nsSeparator__);
        return count(partsø1) > 1 ? partsø1[0] : void 0;
    }.call(this);
};
var symbolNamespace = function symbolNamespace(x) {
    return function () {
        var partsø1 = isString(x) ? split(subs(x, 1), __nsSeparator__) : [
                x.namespace,
                x.name
            ];
        return count(partsø1) > 1 ? partsø1[0] : void 0;
    }.call(this);
};
var namespace = exports.namespace = function namespace(x) {
        return isSymbol(x) ? symbolNamespace(x) : isKeyword(x) ? keywordNamespace(x) : 'else' ? (function () {
            throw new TypeError('' + 'Doesn\'t supports namespace: ' + x);
        })() : void 0;
    };
var gensym = exports.gensym = function gensym(prefix) {
        return symbol('' + (isNil(prefix) ? 'G__' : prefix) + (gensym.base = gensym.base + 1));
    };
gensym.base = 0;
var isUnquote = exports.isUnquote = function isUnquote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'unquote'));
    };
var isUnquoteSplicing = exports.isUnquoteSplicing = function isUnquoteSplicing(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'unquote-splicing'));
    };
var isQuote = exports.isQuote = function isQuote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'quote'));
    };
var isSyntaxQuote = exports.isSyntaxQuote = function isSyntaxQuote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'syntax-quote'));
    };
var normalize = function normalize(n, len) {
    return function loop() {
        var recur = loop;
        var nsø1 = '' + n;
        do {
            recur = count(nsø1) < len ? (loop[0] = '' + '0' + nsø1, loop) : nsø1;
        } while (nsø1 = loop[0], recur === loop);
        return recur;
    }.call(this);
};
var quoteString = exports.quoteString = function quoteString(s) {
        s = join('\\"', split(s, '"'));
        s = join('\\\\', split(s, '\\'));
        s = join('\\b', split(s, '\b'));
        s = join('\\f', split(s, '\f'));
        s = join('\\n', split(s, '\n'));
        s = join('\\r', split(s, '\r'));
        s = join('\\t', split(s, '\t'));
        return '' + '"' + s + '"';
    };
var prStr = exports.prStr = function prStr(x, offset) {
        return function () {
            var offsetø2 = offset || 0;
            return isNil(x) ? 'nil' : isKeyword(x) ? namespace(x) ? '' + ':' + namespace(x) + '/' + name(x) : '' + ':' + name(x) : isSymbol(x) ? namespace(x) ? '' + namespace(x) + '/' + name(x) : name(x) : isString(x) ? quoteString(x) : isDate(x) ? '' + '#inst "' + x.getUTCFullYear() + '-' + normalize(inc(x.getUTCMonth()), 2) + '-' + normalize(x.getUTCDate(), 2) + 'T' + normalize(x.getUTCHours(), 2) + ':' + normalize(x.getUTCMinutes(), 2) + ':' + normalize(x.getUTCSeconds(), 2) + '.' + normalize(x.getUTCMilliseconds(), 3) + '-' + '00:00"' : isVector(x) ? '' + '[' + join('' + '\n ' + join(repeat(inc(offsetø2), ' ')), map(function ($1) {
                return prStr($1, inc(offsetø2));
            }, vec(x))) + ']' : isDictionary(x) ? '' + '{' + join('' + ',\n' + join(repeat(inc(offsetø2), ' ')), map(function (pair) {
                return function () {
                    var indentø1 = join(repeat(offsetø2, ' '));
                    var keyø1 = prStr(first(pair), inc(offsetø2));
                    var valueø1 = prStr(second(pair), 2 + offsetø2 + count(keyø1));
                    return '' + keyø1 + ' ' + valueø1;
                }.call(this);
            }, x)) + '}' : isSequential(x) ? '' + '(' + join(' ', map(function ($1) {
                return prStr($1, inc(offsetø2));
            }, vec(x))) + ')' : isRePattern(x) ? '' + '#"' + join('\\/', split(x.source, '/')) + '"' : 'else' ? '' + x : void 0;
        }.call(this);
    };