{
    var _ns_ = {
            id: 'wisp.backend.javascript.writer',
            doc: 'Compiler backend for for writing JS output'
        };
    var wisp_ast = require('./../../ast');
    var name = wisp_ast.name;
    var namespace = wisp_ast.namespace;
    var symbol = wisp_ast.symbol;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var wisp_sequence = require('./../../sequence');
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var isList = wisp_sequence.isList;
    var vec = wisp_sequence.vec;
    var map = wisp_sequence.map;
    var count = wisp_sequence.count;
    var last = wisp_sequence.last;
    var reduce = wisp_sequence.reduce;
    var isEmpty = wisp_sequence.isEmpty;
    var wisp_runtime = require('./../../runtime');
    var isTrue = wisp_runtime.isTrue;
    var isNil = wisp_runtime.isNil;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isDictionary = wisp_runtime.isDictionary;
    var isBoolean = wisp_runtime.isBoolean;
    var isRePattern = wisp_runtime.isRePattern;
    var reFind = wisp_runtime.reFind;
    var dec = wisp_runtime.dec;
    var subs = wisp_runtime.subs;
    var isEqual = wisp_runtime.isEqual;
    var wisp_string = require('./../../string');
    var replace = wisp_string.replace;
    var join = wisp_string.join;
    var split = wisp_string.split;
    var upperCase = wisp_string.upperCase;
}
var writeReference = exports.writeReference = function writeReference(form) {
        'Translates references from clojure convention to JS:\n\n  **macros**      __macros__\n  list->vector    listToVector\n  set!            set\n  foo_bar         foo_bar\n  number?         isNumber\n  create-server   createServer';
        return function () {
            var idø1 = name(form);
            idø1 = idø1 === '*' ? 'multiply' : idø1 === '/' ? 'divide' : idø1 === '+' ? 'sum' : idø1 === '-' ? 'subtract' : idø1 === '=' ? 'equal?' : idø1 === '==' ? 'strict-equal?' : idø1 === '<=' ? 'not-greater-than' : idø1 === '>=' ? 'not-less-than' : idø1 === '>' ? 'greater-than' : idø1 === '<' ? 'less-than' : 'else' ? idø1 : void 0;
            idø1 = join('_', split(idø1, '*'));
            idø1 = join('-to-', split(idø1, '->'));
            idø1 = join(split(idø1, '!'));
            idø1 = join('$', split(idø1, '%'));
            idø1 = join('-plus-', split(idø1, '+'));
            idø1 = join('-and-', split(idø1, '&'));
            idø1 = last(idø1) === '?' ? '' + 'is-' + subs(idø1, 0, dec(count(idø1))) : idø1;
            idø1 = reduce(function (result, key) {
                return '' + result + (!isEmpty(result) && !isEmpty(key) ? '' + upperCase((key || 0)[0]) + subs(key, 1) : key);
            }, '', split(idø1, '-'));
            return idø1;
        }.call(this);
    };
var writeKeywordReference = exports.writeKeywordReference = function writeKeywordReference(form) {
        return '' + '"' + name(form) + '"';
    };
var writeKeyword = exports.writeKeyword = function writeKeyword(form) {
        return '' + '"' + '\uA789' + name(form) + '"';
    };
var writeSymbol = exports.writeSymbol = function writeSymbol(form) {
        return write(list(symbol(void 0, 'symbol'), namespace(form), name(form)));
    };
var writeNil = exports.writeNil = function writeNil(form) {
        return 'void(0)';
    };
var writeNumber = exports.writeNumber = function writeNumber(form) {
        return form;
    };
var writeBoolean = exports.writeBoolean = function writeBoolean(form) {
        return isTrue(form) ? 'true' : 'false';
    };
var writeString = exports.writeString = function writeString(form) {
        form = replace(form, RegExp('\\\\', 'g'), '\\\\');
        form = replace(form, RegExp('\n', 'g'), '\\n');
        form = replace(form, RegExp('\r', 'g'), '\\r');
        form = replace(form, RegExp('\t', 'g'), '\\t');
        form = replace(form, RegExp('"', 'g'), '\\"');
        return '' + '"' + form + '"';
    };
var writeTemplate = exports.writeTemplate = function writeTemplate() {
        var form = Array.prototype.slice.call(arguments, 0);
        return function () {
            var indentPatternø1 = /\n *$/;
            var lineBreakPatterø1 = RegExp('\n', 'g');
            var getIndentationø1 = function (code) {
                return reFind(indentPatternø1, code) || '\n';
            };
            return function loop() {
                var recur = loop;
                var codeø1 = '';
                var partsø1 = split(first(form), '~{}');
                var valuesø1 = rest(form);
                do {
                    recur = count(partsø1) > 1 ? (loop[0] = '' + codeø1 + first(partsø1) + replace('' + '' + first(valuesø1), lineBreakPatterø1, getIndentationø1(first(partsø1))), loop[1] = rest(partsø1), loop[2] = rest(valuesø1), loop) : '' + codeø1 + first(partsø1);
                } while (codeø1 = loop[0], partsø1 = loop[1], valuesø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var writeGroup = exports.writeGroup = function writeGroup() {
        var forms = Array.prototype.slice.call(arguments, 0);
        return join(', ', forms);
    };
var writeInvoke = exports.writeInvoke = function writeInvoke(callee) {
        var params = Array.prototype.slice.call(arguments, 1);
        return writeTemplate('~{}(~{})', callee, writeGroup.apply(void 0, params));
    };
var writeError = exports.writeError = function writeError(message) {
        return function () {
            return (function () {
                throw Error(message);
            })();
        };
    };
var writeVector = exports.writeVector = writeError('Vectors are not supported');
var writeDictionary = exports.writeDictionary = writeError('Dictionaries are not supported');
var escapePattern = function escapePattern(pattern) {
    pattern = join('/', split(pattern, '\\/'));
    pattern = join('\\/', split(pattern, '/'));
    return pattern;
};
var writeRePattern = exports.writeRePattern = function writeRePattern(form) {
        return function () {
            var flagsø1 = '' + (form.multiline ? 'm' : '') + (form.ignoreCase ? 'i' : '') + (form.sticky ? 'y' : '');
            var patternø1 = form.source;
            return '' + '/' + escapePattern(patternø1) + '/' + flagsø1;
        }.call(this);
    };
var compileComment = exports.compileComment = function compileComment(form) {
        return compileTemplate(list('//~{}\n', first(form)));
    };
var writeDef = exports.writeDef = function writeDef(form) {
        return function () {
            var idø1 = first(form);
            var isExportø1 = (meta(form) || {} || 0)['top'] && !(meta(idø1) || {} || 0)['private'];
            var attributeø1 = symbol(namespace(idø1), '' + '-' + name(idø1));
            return isExportø1 ? compileTemplate(list('var ~{};\n~{}', compile(cons(symbol(void 0, 'set!'), form)), compile(list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, '.')].concat([symbol(void 0, 'exports')], [attributeø1]))], [idø1]))))) : compileTemplate(list('var ~{}', compile(cons(symbol(void 0, 'set!'), form))));
        }.call(this);
    };
var isWriteInstance = exports.isWriteInstance = function isWriteInstance(form) {
        return writeTemplate('~{} instanceof ~{}', write(second(form)), write(first(form)));
    };
var write = exports.write = function write(form) {
        return isNil(form) ? writeNil(form) : isSymbol(form) ? writeReference(form) : isKeyword(form) ? writeKeywordReference(form) : isString(form) ? writeString(form) : isNumber(form) ? writeNumber(form) : isBoolean(form) ? writeBoolean(form) : isRePattern(form) ? writePattern(form) : isVector(form) ? writeVector(form) : isDictionary(form) ? writeDictionary() : isList(form) ? writeInvoke.apply(void 0, map(write, vec(form))) : 'else' ? writeError('Unsupported form') : void 0;
    };